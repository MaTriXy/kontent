# Kontent

This small library is created to help reduce the boilerplate involved in using Model-View-Intent

The inspiration for this library and the articles comes from this [Hannes Dorfmann’s series](https://medium.com/r/?url=http%3A%2F%2Fhannesdorfmann.com%2Fandroid%2Fmosby3-mvi-1) and [Benoît Quenaudon’s talk at Droidcon NYC 2017](https://medium.com/r/?url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DPXBXcHQeDLE)


## What is MVI
(I am currently in the process of writing a short acrticle series that gives a deep dive into MVI and each component)

MVI is designed to overcome some of the limitations of Model-View-Presenter (MVP) and Model-View-Controller (MVC). Below is some of the main issues:
* Ui logic often becomes mixed with business logic.
* Screen orientations become difficult.
* State — it’s extremely difficult (if not impossible) to reason about application state (due to the multidirectional data flow).
* Testability — the state issue makes it difficult to replicate state and therefore write meaningful tests.

![MVI](https://raw.githubusercontent.com/gumil/basamto/master/art/mvi.png)

As you can see above MVI helps enable a uniderectional data flow and facilitates a more functional approach. The library is heavily dependent on RxJava and Kotlin.

## Intent
An intent is generated by the ui. This would be something like AddItemIntent, intents in this context are not an android Intent. An intent will look like the following
```
sealed class TodoListIntent : KontentIntent() {
    class LoadTodoListItems : TodoListIntent()
    data class ChangeItemStatus(val itemId: Long, val itemStatus: TodoItemState) : TodoListIntent()
    data class AddItem(val title: String, val description: String): TodoListIntent()
}
```

An intent is generated by ui, for example you may have a function like the following in your activity:
```
  private fun adapterIntent(): Observable<TodoListIntent> = Observable.create { emitter ->
        adapter.onItemSelected = { serverId, selected ->
            val state = when (selected) {
                true -> TodoItemState.COMPLETED
                false -> TodoItemState.ACTIVE
            }
            emitter.onNext(TodoListIntent.ChangeItemStatus(serverId, state))
        }
    }
```

## Intent -> Action
This is a pure function that converts an intent to an action. This is a step that abbstracts the user intents from the business logic. This would look something like the following:
```
fun listIntentToAction(intent: TodoListIntent): TodoListAction = when (intent) {
    is TodoListIntent.LoadTodoListItems -> TodoListAction.LoadItems()
    is TodoListIntent.ChangeItemStatus -> TodoListAction.ChangeItemStatus(intent.itemId, intent.itemStatus)
    is TodoListIntent.AddItem -> TodoListAction.AddItem(intent.title, intent.description)
}
```

## ActionProcessor
This is an important part of MVI and the function where stuff happens and side effects occur. This is the part where you would make network calls and you may write to files. A processor generate a result to be passed to the reducer, a processor function looks something like the following:
```
private fun loadItemsLoadProcessor(listItemRepository: IListItemRepository) = KontentActionProcessor<TodoListAction.LoadItems, TodoListResult, List<TodoItem>>(
        action = { listItemRepository.getListItems() },
        success = { TodoListResult.ListLoadSuccess(it) },
        error = { TodoListResult.Error(it) },
        loading = TodoListResult.ListLoadInflight())
```

## Result
TODO

## Reducer
TODO

## State
TODO

## Notes (section for putting random information, will structure better later)

Generics Symbols:
```
I : Intent
A : Action
R : Result
S : ViewState
```
